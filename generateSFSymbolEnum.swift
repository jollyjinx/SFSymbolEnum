import Foundation

typealias ReleaseDate = String
typealias Symbol = String
typealias Symbols = [Symbol:ReleaseDate]
typealias Release = [String:String]
typealias Releases = [ReleaseDate:Release]
typealias SymbolTuple = (symbol:Symbol,released:ReleaseDate)

extension Release {
    var availabilty:String {
        "available(" +
        self.map{ (os,version) in os + " " + version }.sorted().joined(separator: ",") +
        ",*)"
    }

    var objcAvailability:String {
        let mappings = self.map { (os, version) in
            "\(os.lowercased())(\(version))"
        }.sorted()

        return "API_AVAILABLE(" + mappings.joined(separator: ", ") + ")"
    }
}

extension Symbol {
    var replacementName:String {
        guard !Set(["return","case","repeat"]).contains(self) else { return "`"+self+"`" }
        let parts = components(separatedBy:".")
        let firstElement = parts.first!
        let camelCase = firstElement + parts.dropFirst().map{ $0.prefix(1).uppercased() + $0.dropFirst()}.joined(separator: "")
        return camelCase.first?.isNumber == true ? "number" + camelCase : camelCase
    }

    var objcEnumName:String {
        let parts = components(separatedBy:".")
        let pascalCase = parts.map{ $0.prefix(1).uppercased() + $0.dropFirst()}.joined(separator: "")
        return "SFSymbol" + pascalCase
    }
}


// Parse command line arguments
let outputObjectiveC = CommandLine.arguments.contains("--objc")
let outputObjectiveCImpl = CommandLine.arguments.contains("--objc-impl")

let plistURL: URL = {
    let betaURL = URL(fileURLWithPath: "/Applications/SF Symbols beta.app/Contents/Resources/Metadata/name_availability.plist")
    let oldURL = URL(fileURLWithPath:"/Applications/SF Symbols.app/Contents/Resources/Metadata-Public/name_availability.plist")
    let newURL = URL(fileURLWithPath:"/Applications/SF Symbols.app/Contents/Resources/Metadata/name_availability.plist")
    if FileManager.default.fileExists(atPath: betaURL.path) {
        return betaURL
    } else if FileManager.default.fileExists(atPath: oldURL.path) {
        return oldURL
    } else {
        return newURL
    }
}()
let (sortedSymbolTuple,releaseYears) = readSymbolsAndYears(from:plistURL)

if outputObjectiveC {
    // Generate Objective-C header to stdout
    generateObjectiveCHeader(sortedSymbolTuple: sortedSymbolTuple, releaseYears: releaseYears)
} else if outputObjectiveCImpl {
    // Generate Objective-C implementation to stdout
    generateObjectiveCImplementation(sortedSymbolTuple: sortedSymbolTuple, releaseYears: releaseYears)
} else {
    // Generate Swift code to stdout
    generateSwiftCode(sortedSymbolTuple: sortedSymbolTuple, releaseYears: releaseYears)
}

exit(0)


func generateSwiftCode(sortedSymbolTuple: [SymbolTuple], releaseYears: Releases) {
    print(
    """
    // this file has been generated
    // you can recreate it using generateSFSymbolEnum.swift script
    import Foundation

    public enum SFSymbol:String
    {
    """)

    for symbolTuple in sortedSymbolTuple
    {
        print("    @" + releaseYears[symbolTuple.released]!.availabilty + " case " + symbolTuple.symbol.replacementName + " = \"" + symbolTuple.symbol + "\"" )
    }
    print(
    """
    }
    extension SFSymbol:CaseIterable
    {
        public static let allCases:[SFSymbol] = {
                    var allCases:[SFSymbol] = []
    """)

    var lastavailablity = ""
    for symbolTuple in sortedSymbolTuple
    {
        if symbolTuple.released != lastavailablity
        {
            if lastavailablity != ""
            {
                print("\n            ])\n        }\n")
            }
            lastavailablity = symbolTuple.released
            print("        if #" + releaseYears[symbolTuple.released]!.availabilty + "{")
            print("            allCases.append(contentsOf: [")
            print("                SFSymbol." + symbolTuple.symbol.replacementName , terminator:"")
        }
        else
        {
            print(",\n                SFSymbol." + symbolTuple.symbol.replacementName, terminator:"")
        }
    }

    print(
    """

            ])
        }

        return allCases
        }()
    }
    """)
}


func generateObjectiveCHeader(sortedSymbolTuple: [SymbolTuple], releaseYears: Releases) {
    print(
    """
    // This file has been generated
    // You can recreate it using generateSFSymbolEnum.swift script with --objc flag
    //
    // DO NOT EDIT - This file is automatically generated

    #import <Foundation/Foundation.h>
    #import <Availability.h>

    NS_ASSUME_NONNULL_BEGIN

    typedef NS_ENUM(NSInteger, SFSymbol) {
    """)

    // Group symbols by release date for proper availability annotations
    var symbolsByRelease: [ReleaseDate: [SymbolTuple]] = [:]
    for symbolTuple in sortedSymbolTuple {
        symbolsByRelease[symbolTuple.released, default: []].append(symbolTuple)
    }

    // Sort release dates
    let sortedReleaseDates = symbolsByRelease.keys.sorted()

    var isFirst = true
    var enumValue = 0
    for releaseDate in sortedReleaseDates {
        guard let release = releaseYears[releaseDate],
              let symbols = symbolsByRelease[releaseDate] else { continue }

        if !isFirst {
            print("")
        }
        isFirst = false

        // Add comment for this group
        print("    // Symbols introduced in \(releaseDate)")

        for (index, symbol) in symbols.enumerated() {
            let isLastInGroup = index == symbols.count - 1
            let isLastOverall = releaseDate == sortedReleaseDates.last && isLastInGroup
            let comma = isLastOverall ? "" : ","
            print("    \(symbol.symbol.objcEnumName) \(release.objcAvailability) = \(enumValue)\(comma)")
            enumValue += 1
        }
    }

    print(
    """
    };

    // Get string representation of SFSymbol
    NSString * _Nullable SFSymbolGetString(SFSymbol symbol);

    // Check if a symbol is available on the current platform
    BOOL SFSymbolIsAvailable(SFSymbol symbol);

    NS_ASSUME_NONNULL_END
    """)
}

func generateObjectiveCImplementation(sortedSymbolTuple: [SymbolTuple], releaseYears: Releases) {
    print(
    """
    // This file has been generated
    // You can recreate it using generateSFSymbolEnum.swift script with --objc-impl flag
    //
    // DO NOT EDIT - This file is automatically generated

    #import "SFSymbolEnum.h"

    NSString * _Nullable SFSymbolGetString(SFSymbol symbol) {
        switch (symbol) {
    """)

    // Generate switch cases for all symbols
    var enumValue = 0
    for symbolTuple in sortedSymbolTuple {
        print("        case \(symbolTuple.symbol.objcEnumName): return @\"\(symbolTuple.symbol)\";")
        enumValue += 1
    }

    print(
    """
            default: return nil;
        }
    }

    BOOL SFSymbolIsAvailable(SFSymbol symbol) {
    """)

    // Group symbols by release date for availability checks
    var symbolsByRelease: [ReleaseDate: [SymbolTuple]] = [:]
    for symbolTuple in sortedSymbolTuple {
        symbolsByRelease[symbolTuple.released, default: []].append(symbolTuple)
    }

    // Sort release dates from newest to oldest for optimal checking
    let sortedReleaseDates = symbolsByRelease.keys.sorted(by: >)

    // Generate availability checks
    var enumValueForAvailability = 0
    for (index, releaseDate) in sortedReleaseDates.enumerated() {
        guard let release = releaseYears[releaseDate],
              let symbols = symbolsByRelease[releaseDate] else { continue }

        // Build the @available condition
        var availableConditions: [String] = []
        if let iosVersion = release["iOS"] {
            availableConditions.append("iOS \(iosVersion)")
        }
        if let macosVersion = release["macOS"] {
            availableConditions.append("macOS \(macosVersion)")
        }
        if let tvosVersion = release["tvOS"] {
            availableConditions.append("tvOS \(tvosVersion)")
        }
        if let watchosVersion = release["watchOS"] {
            availableConditions.append("watchOS \(watchosVersion)")
        }
        if let visionosVersion = release["visionOS"] {
            availableConditions.append("visionOS \(visionosVersion)")
        }

        let availableString = availableConditions.joined(separator: ", ")

        // Calculate the enum range for this release
        let firstValue = enumValueForAvailability
        let lastValue = enumValueForAvailability + symbols.count - 1

        if index == 0 {
            print("    if (@available(\(availableString), *)) {")
        } else {
            print("    } else if (@available(\(availableString), *)) {")
        }

        print("        return (symbol >= \(firstValue) && symbol <= \(lastValue));")

        enumValueForAvailability += symbols.count
    }

    print(
    """
        } else {
            return NO;
        }
    }
    """)
}

func readSymbolsAndYears(from fileURL:URL) -> ( [SymbolTuple],Releases)
{
    let data = try! Data.init(contentsOf: fileURL, options: .mappedIfSafe)
    let propertyList = try! PropertyListSerialization.propertyList(from:data,options:[],format:nil) as! Dictionary<String,Any>

    let symbols     = propertyList["symbols"] as! Symbols
    let releases    = propertyList["year_to_release"] as! Releases

    let releaseDatesFromSymbols     = Set<ReleaseDate>(symbols.values)
    let releaseDatesFromReleases    = Set<ReleaseDate>(releases.keys)

    assert(releaseDatesFromReleases.isSubset(of:releaseDatesFromSymbols),"There are symbols with relasedates that have no release versions \(releaseDatesFromReleases) < \(releaseDatesFromSymbols)")

    let sortedSymbolTuple = symbols
                            .sorted{ $0.value == $1.value ? $0.key < $1.key : $0.value < $1.value}
                            .map{ SymbolTuple(symbol:$0.key,released:$0.value) }

    return (sortedSymbolTuple,releases)
}
